<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://github.com/accenture/mercury-nodejs/guides/CHAPTER-4/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Chapter-4 - Composable for Node.js</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Chapter-4";
        var mkdocs_page_input_path = "guides/CHAPTER-4.md";
        var mkdocs_page_url = "/accenture/mercury-nodejs/guides/CHAPTER-4/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Composable for Node.js
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../METHODOLOGY/">Methodology</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-1/">Chapter-1</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-2/">Chapter-2</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-3/">Chapter-3</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Chapter-4</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#flow-list">Flow list</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#multiple-flow-lists">Multiple flow lists</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#writing-new-rest-endpoint-and-function">Writing new REST endpoint and function</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#flow-configuration-syntax">Flow configuration syntax</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#underlying-event-system">Underlying Event System</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#rest-automation-and-http-flow-adapter">REST automation and HTTP flow adapter</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#task-and-its-corresponding-function">Task and its corresponding function</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#unique-task-naming">Unique task naming</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#hierarchy-of-flows">Hierarchy of flows</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#tasks-and-data-mapping">Tasks and data mapping</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#inputoutput-data-mapping">Input/Output data mapping</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#environment-variables">Environment variables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#runtime-model-variables">Runtime model variables</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#handling-arrays-in-a-dataset">Handling arrays in a dataset</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#append-an-element-to-an-array">Append an element to an array</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#simple-type-matching-and-conversion">Simple type matching and conversion</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#convenient-data-mapping-using-model-variable">Convenient data mapping using model variable</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#metadata-for-each-flow-instance">Metadata for each flow instance</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#special-handling-for-header">Special handling for header</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-input-and-output">Function input and output</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#setting-function-input-headers">Setting function input headers</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#task-types">Task types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#decision-task">Decision task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#response-task">Response task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#end-task">End task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sequential-task">Sequential task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#parallel-task">Parallel task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#fork-n-join-task">Fork-n-join task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dynamic-fork-n-join-task">Dynamic fork-n-join task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sink-task">Sink task</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pipeline-feature">Pipeline feature</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#pipeline-task">Pipeline task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#simple-for-loop">Simple for-loop</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#simple-while-loop">Simple while loop</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#for-loop-with-breakcontinue-decision">For loop with break/continue decision</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#handling-exception">Handling exception</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#top-level-exception-handler">Top-level exception handler</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#task-level-exception-handler">Task-level exception handler</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#best-practice">Best practice</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#advanced-features">Advanced features</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#no-operation-function">No-operation function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#generic-resilience-handler-function">Generic resilience handler function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#external-state-machine">External state machine</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#future-task-scheduling">Future task scheduling</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#using-worker-threads">Using Worker Threads</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-5/">Chapter-5</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-6/">Chapter-6</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-7/">Chapter-7</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-8/">Chapter-8</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../APPENDIX-I/">Appendix-I</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../APPENDIX-II/">Appendix-II</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG/">Release notes</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../arch-decisions/DESIGN-NOTES/">Design notes</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../INCLUSIVITY/">Inclusivity</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../CODE_OF_CONDUCT/">Code of Conduct</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../CONTRIBUTING/">Contribution</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../TABLE-OF-CONTENTS/">Contents</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Composable for Node.js</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Chapter-4</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="event-script-syntax">Event Script Syntax</h1>
<p>Event Script is a Domain Specific Language (DSL) that uses YAML to represent an end-to-end transaction flow.
A transaction is a business use case, and the flow can be an API service, a batch job or a real-time transaction.</p>
<h2 id="flow-list">Flow list</h2>
<p>This configuration file sits in the project "resources" project and contains a list of filenames.</p>
<p>The default flow list is "flows.yaml" under the "resources" folder. It may look like this.</p>
<pre><code class="language-yaml">flows:
  - 'get-profile.yml'
  - 'create-profile.yml'
  - 'delete-profile.yml'

location: 'classpath:/flows/'
</code></pre>
<p>The "location" parameter is optional. If present, you can tell the system to load the flow config files from
another folder location.</p>
<h2 id="multiple-flow-lists">Multiple flow lists</h2>
<p>You can provide more than one flow list to your application and it can become very handy under different
situations. For instance, to achieve better modularity in complex application, flows can be grouped to
multiple categories based on development team's choice and these flows can be managed in multiple flow
lists. Another great place to use multiple flow list is to include external libraries which contain
pre-defined flow lists. The following example demonstrates that an application loads a list of flows
defined in "flows.yaml" and additional flows defined in "more-flows.yaml" file of a composable library.</p>
<pre><code class="language-properties">yaml.flow.automation=classpath:/flows.yaml, classpath:/more-flows.yaml
</code></pre>
<h2 id="writing-new-rest-endpoint-and-function">Writing new REST endpoint and function</h2>
<p>You can use the "composable-example" subproject as a template to write your own composable application.</p>
<p>Before you update the code, please clean the project using <code>npm run clean</code>. This will remove the scanned
list of composable functions in the ComposableLoader (<code>preload.ts</code>) class so that you can write your own
functions.</p>
<p>For each filename in the flows.yml, you should create a corresponding configuration file under the
"resources/flows" folder.</p>
<p>Let's write a new flow called "greetings". You can copy-n-paste the following into a file called "greetings.yml"
under the "resources/flows" folder.</p>
<pre><code class="language-yaml">flow:
  id: 'greetings'
  description: 'Simplest flow'
  ttl: 10s

first.task: 'greeting.demo'

tasks:
  - input:
      - 'input.path_parameter.user -&gt; user'
    process: 'greeting.demo'
    output:
      - 'text(application/json) -&gt; output.header.content-type'
      - 'result -&gt; output.body'
    description: 'Hello World'
    execution: end
</code></pre>
<p>In the application.properties, you can specify the following parameter:</p>
<pre><code class="language-properties">yaml.flow.automation=classpath:/flows.yaml
</code></pre>
<p>and update the "flows.yaml" file in the resources folder as follows:</p>
<pre><code class="language-yaml">flows:
  - 'get-profile.yml'
  - 'create-profile.yml'
  - 'delete-profile.yml'
  - 'greetings.yml'
</code></pre>
<p>Then, you can add a new REST endpoint in the "rest.yaml" configuration file like this.</p>
<pre><code class="language-yaml">  - service: &quot;http.flow.adapter&quot;
    methods: ['GET']
    url: &quot;/api/greetings/{user}&quot;
    flow: 'greetings'
    timeout: 10s
    cors: cors_1
    headers: header_1
</code></pre>
<p>The above REST endpoint takes the path parameter "user". The task executor will map the path parameter to the
input arguments (headers and body) in your function. Now you can write your new function with the named route
"greeting.demo". Please copy-n-paste the following into a TypeScript class called "greetings.ts" and save it
under the "tasks" folder in the source project.</p>
<pre><code class="language-shell">import { AppException, Composable, EventEnvelope, preload } from &quot;mercury-composable&quot;;

export class Greetings implements Composable {
    @preload('greeting.demo', 10)
    initialize(): Composable {
        return this;
    }

    async handleEvent(evt: EventEnvelope) {
        const input = evt.getBody() as object;
        if ('user' in input) {
            const result = {};
            result['time'] = new Date().toISOString();
            result['message'] = 'Welcome';
            result['user'] = input['user'];
            return result;
        } else {
            throw new AppException(400, &quot;Missing path parameter 'user'&quot;)
        }
    }
}
</code></pre>
<p>To test your new REST endpoint, flow configuration and function, please point your browser to</p>
<pre><code class="language-text">http://127.0.0.1:8086/api/greetings/my_name
</code></pre>
<p>You can replace "my_name" with your first name to see the response to the browser.</p>
<h2 id="flow-configuration-syntax">Flow configuration syntax</h2>
<p>In your "greetings.yml" file above, you find the following key-values:</p>
<p><code>flow.id</code> - Each flow must have a unique flow ID. The flow ID is usually originated from a user facing endpoint
through an event adapter. For example, you may write an adapter to listen to a cloud event in a serverless deployment.
In The most common one is the HTTP adapter.</p>
<p>The flow ID is originated from the "rest.yaml". The <code>flow-engine</code> will find the corresponding flow configuration
and create a new flow instance to process the user request.</p>
<p><code>flow.description</code> - this describes the purpose of the flow</p>
<p><code>flow.ttl</code> - "Time to live (TTL)" timer for each flow. You can define the maximum time for a flow to finish processing.
All events are delivered asynchronously and there is no timeout value for each event. The TTL defines the time budget
for a complete end-to-end flow. Upon expiry, an unfinished flow will be aborted. You can use suffix "s" for seconds,
"m" for minutes and "h" for hours. e.g. "30s" for 30 seconds.</p>
<blockquote>
<p><em>Note</em>: When using the HTTP Flow Adapter, the flow.ttl value can be higher than the REST endpoint's timeout value.
  This would happen when one of your tasks in the event flow responds to the caller and the event flow continues to
  execute the rest of the flow. This type of task is called "response" task.</p>
</blockquote>
<p><code>first.task</code> - this points to the route name of a function (aka "task") to which the flow engine will deliver
the incoming event.</p>
<p>The configuration file contains a list of task entries where each task is defined by "input", "process", "output"
and "execution" type. In the above example, the execution type is "end", meaning that it is the end of a transaction
and its result set will be delivered to the user.</p>
<h2 id="underlying-event-system">Underlying Event System</h2>
<p>The Event Script system uses platform-core as the event system where it encapsulates EventEmitter from the standard
library of Node.js.</p>
<p>The integration points are intentionally minimalist. For most use cases, the user application does not need
to make any API calls to the underlying event system.</p>
<h2 id="rest-automation-and-http-flow-adapter">REST automation and HTTP flow adapter</h2>
<p>The most common transaction entry point is a REST endpoint. The event flow may look like this:</p>
<pre><code class="language-text">REQUEST -&gt; &quot;http.request&quot; -&gt; &quot;task.executor&quot; -&gt; user defined tasks
        -&gt; &quot;async.http.response&quot; -&gt; RESPONSE
</code></pre>
<p>REST automation is part of the platform-core library. It contains a non-blocking HTTP server that converts
HTTP requests and responses into events.</p>
<p>It routes an HTTP request event to the HTTP adapter if the "flow" tag is provided.</p>
<p>In the following example, the REST endpoint definition is declared in a "rest.yaml" configuration. It will route
the URI "/api/decision" to the HTTP flow adapter that exposes its service route name as "http.flow.adapter".</p>
<pre><code class="language-yaml">rest:
  - service: &quot;http.flow.adapter&quot;
    methods: ['GET']
    url: &quot;/api/decision?decision=_&quot;
    flow: 'decision-test'
    timeout: 10s
    cors: cors_1
    headers: header_1
    tracing: true
</code></pre>
<p>The "cors" and "headers" sections are optional. When specified, the REST endpoint will insert CORS headers and HTTP
request headers accordingly.</p>
<p>For REST automation syntax, please refer to <a href="../CHAPTER-3/">Chapter 3</a></p>
<p>The HTTP flow adapter maps the HTTP request dataset and the flow ID into a standard event envelope for delivery
to the flow engine.</p>
<p>The HTTP request dataset, addressable with the "input." namespace, contains the following:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Key</th>
<th style="text-align: left;">Values</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">method</td>
<td style="text-align: left;">HTTP method</td>
</tr>
<tr>
<td style="text-align: left;">uri</td>
<td style="text-align: left;">URI path</td>
</tr>
<tr>
<td style="text-align: left;">header</td>
<td style="text-align: left;">HTTP headers</td>
</tr>
<tr>
<td style="text-align: left;">cookie</td>
<td style="text-align: left;">HTTP cookies</td>
</tr>
<tr>
<td style="text-align: left;">path_parameter</td>
<td style="text-align: left;">Path parameters if any</td>
</tr>
<tr>
<td style="text-align: left;">query</td>
<td style="text-align: left;">HTTP query parameters if any</td>
</tr>
<tr>
<td style="text-align: left;">body</td>
<td style="text-align: left;">HTTP request body if any</td>
</tr>
<tr>
<td style="text-align: left;">stream</td>
<td style="text-align: left;">input stream route ID if any</td>
</tr>
<tr>
<td style="text-align: left;">ip</td>
<td style="text-align: left;">remote IP address</td>
</tr>
<tr>
<td style="text-align: left;">filename</td>
<td style="text-align: left;">filename if request is a multipart file upload</td>
</tr>
<tr>
<td style="text-align: left;">session</td>
<td style="text-align: left;">authenticated session key-values if any</td>
</tr>
</tbody>
</table>
<p>For easy matching, please use lower case for headers, cookies, query and path parameters.</p>
<p>Regular API uses JSON that will be converted to an object of key-values in the event's body.</p>
<h2 id="task-and-its-corresponding-function">Task and its corresponding function</h2>
<p>Each task in a flow must have a corresponding function. You can assign a task name to the function using the
<code>preload</code> annotation like this.</p>
<pre><code class="language-shell">@preload('greeting.demo', 10)
initialize(): Composable {
    return this;
}
</code></pre>
<p>The "route" in the <code>preload</code> annotation is the task name. The concurrency number define the maximum number of 
"workers" that the function can handle concurrently. The system is designed to be reactive and the function does
not consume memory and CPU resources until an event arrives.</p>
<h2 id="unique-task-naming">Unique task naming</h2>
<p>Composable functions are designed to be reusable. By changing some input data mapping to feed different parameters
and payload, your function can behave differently.</p>
<p>Therefore, it is quite common to use the same function (i.e. the <code>process</code> parameter) more than once in a single
event flow.</p>
<p>When a task is not named, the "process" parameter is used to name the task.</p>
<p>Since each task must have a unique name for event routing, we cannot use the same "process" name more than once in
an event flow. To handle this use case, you can create unique names for the same function using the <code>name</code> parameter
like this:</p>
<pre><code class="language-yaml">flow:
  id: 'greetings'
  description: 'Simplest flow'
  ttl: 10s

first.task: 'my.first.task'

tasks:
  - name: 'my.first.task'
    input:
      - 'input.path_parameter.user -&gt; user'
    process: 'greeting.demo'
    output:
      - 'text(application/json) -&gt; output.header.content-type'
      - 'result -&gt; output.body'
    description: 'Hello World'
    execution: sequential
    next:
      - 'another.task'
</code></pre>
<p>The above event flow configuration uses "my.first.task" as a named route for "greeting.demo" by adding the
"name" parameter to the composable function.</p>
<blockquote>
<p><em>Note</em>: The Event Manager performs event choreography using the unique task name.
  Therefore, when the "process" name for the function is not unique, you must create unique task "names"
  for the same function to ensure correct routing.</p>
</blockquote>
<h2 id="hierarchy-of-flows">Hierarchy of flows</h2>
<p>As shown in Figure 1, you can run one or more sub-flows inside a primary flow.</p>
<p><img alt="Hierarchy of flows" src="../diagrams/parent-namespace.png" /></p>
<blockquote>
<p>Figure 1 - Hierarchy of flows</p>
</blockquote>
<p>To do this, you can use the flow protocol identifier (<code>flow://</code>) to indicate that the task is a flow.
Note that the syntax for input and output data mapping for subflow is the same as a regular task.</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.path_parameter.user -&gt; header.user'
      - 'input.body -&gt; *'
    process: 'flow://my-sub-flow'
    output:
      - 'result -&gt; model.json'
    description: 'Execute a sub-flow'
    execution: sequential
    next:
      - 'my.next.function'
</code></pre>
<p>If the sub-flow is not available, the system will throw an error stating that it is not found.</p>
<p>Hierarchy of flows would reduce the complexity of a single flow configuration file. The "time-to-live (TTL)"
value of the parent flow should be set to a value that covers the complete flow including the time used in
the sub-flows.</p>
<p>In the input/output data mapping sections, the configuration management system provides a parent
state machine using the namespace <code>model.parent.</code> to be shared by the primary flow and all sub-flows that
are instantiated from it.</p>
<p>Just like a task, a subflow has "input" and "output". You can map data to the "input" of a subflow using
the namespaces "body" and "header" where they are maps of key-values. Inside a task of the subflow, 
the body and header namespaces can be accessed for their key-values like this:</p>
<pre><code class="language-yaml">  - input:
      - 'input.header.user -&gt; header.user'
      - 'input.body -&gt; *'
    process: 'first.task.in.subflow'
    output:
      - 'result -&gt; model.parent.subflow_result'
    description: 'Execute a task in a subflow'
    execution: end
</code></pre>
<p>Since the parent flow and subflows has a shared state machine, passing "body" and "header" key-values
to the "input" of a subflow is optional. You can pass key-values between the parent and subflows
using the shared state machine easily.</p>
<blockquote>
<p><em>Note</em>: The namespace <code>model.root.</code> is an alias of <code>model.parent.</code> This would reduce ambiguity
          if you prefer to use "root" referring to the parent flow that creates one or more subflows.</p>
</blockquote>
<h2 id="tasks-and-data-mapping">Tasks and data mapping</h2>
<p>All tasks for a flow are defined in the "tasks" section.</p>
<h3 id="inputoutput-data-mapping">Input/Output data mapping</h3>
<p>A function is self-contained. This modularity reduces application complexity because the developer only needs
interface contract details for a specific function.</p>
<p>To handle this level of modularity, the system provides configurable input/output data mapping.</p>
<p><em>Namespaces for I/O data mapping</em></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Keyword and/or namespace</th>
<th>LHS / RHS</th>
<th>Mappings</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Flow input dataset</td>
<td style="text-align: left;"><code>input.</code></td>
<td>left</td>
<td>input</td>
</tr>
<tr>
<td style="text-align: left;">Flow output dataset</td>
<td style="text-align: left;"><code>output.</code></td>
<td>right</td>
<td>output</td>
</tr>
<tr>
<td style="text-align: left;">Function input body</td>
<td style="text-align: left;">no namespace required</td>
<td>right</td>
<td>input</td>
</tr>
<tr>
<td style="text-align: left;">Function input or output headers</td>
<td style="text-align: left;"><code>header</code> or <code>header.</code></td>
<td>both</td>
<td>I/O</td>
</tr>
<tr>
<td style="text-align: left;">Function output result set</td>
<td style="text-align: left;"><code>result.</code></td>
<td>left</td>
<td>output</td>
</tr>
<tr>
<td style="text-align: left;">Function output status code</td>
<td style="text-align: left;"><code>status</code></td>
<td>left</td>
<td>output</td>
</tr>
<tr>
<td style="text-align: left;">Decision value</td>
<td style="text-align: left;"><code>decision</code></td>
<td>right</td>
<td>output</td>
</tr>
<tr>
<td style="text-align: left;">State machine dataset</td>
<td style="text-align: left;"><code>model.</code></td>
<td>both</td>
<td>I/O</td>
</tr>
<tr>
<td style="text-align: left;">Parent state machine dataset</td>
<td style="text-align: left;"><code>model.parent.</code></td>
<td>both</td>
<td>I/O</td>
</tr>
<tr>
<td style="text-align: left;">External state machine key-value</td>
<td style="text-align: left;"><code>ext:</code></td>
<td>right</td>
<td>I/O</td>
</tr>
</tbody>
</table>
<p>For state machine (model and model.parent namespaces), the system prohibits access to the whole
namespace. You should only access specific key-values in the model or model.parent namespaces.</p>
<p>The namespace <code>model.parent.</code> is shared by the primary flow and all sub-flows that are instantiated from it.</p>
<p>The external state machine namespace uses the namespace <code>ext:</code> to indicate that the key-value is external.</p>
<p><em>Constants for input data mapping</em></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Keyword for the left-hand-side argument</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">String</td>
<td style="text-align: left;"><code>text(example_value)</code></td>
</tr>
<tr>
<td style="text-align: left;">Integer</td>
<td style="text-align: left;"><code>int(number)</code></td>
</tr>
<tr>
<td style="text-align: left;">Long</td>
<td style="text-align: left;"><code>long(number)</code></td>
</tr>
<tr>
<td style="text-align: left;">Float</td>
<td style="text-align: left;"><code>float(number)</code></td>
</tr>
<tr>
<td style="text-align: left;">Double</td>
<td style="text-align: left;"><code>double(number)</code></td>
</tr>
<tr>
<td style="text-align: left;">Boolean</td>
<td style="text-align: left;"><code>boolean(true or false)</code></td>
</tr>
<tr>
<td style="text-align: left;">Map</td>
<td style="text-align: left;"><code>map(k1=v1, k2=v2)</code><br><code>map(base.config.parameter)</code></td>
</tr>
<tr>
<td style="text-align: left;">File</td>
<td style="text-align: left;"><code>file(text:file_path)</code></td>
</tr>
<tr>
<td style="text-align: left;">File</td>
<td style="text-align: left;"><code>file(binary:file_path)</code></td>
</tr>
<tr>
<td style="text-align: left;">File</td>
<td style="text-align: left;"><code>file(json:file_path)</code></td>
</tr>
<tr>
<td style="text-align: left;">Classpath</td>
<td style="text-align: left;"><code>classpath(text:file_path)</code></td>
</tr>
<tr>
<td style="text-align: left;">Classpath</td>
<td style="text-align: left;"><code>classpath(binary:file_path)</code></td>
</tr>
<tr>
<td style="text-align: left;">Classpath</td>
<td style="text-align: left;"><code>classpath(json:file_path)</code></td>
</tr>
</tbody>
</table>
<p>For input data mapping, the "file" constant type is used to load some file content as an argument of a user
function. You can tell the system to render the file as "text", "binary" or "json". Similarly, the 
"classpath" constant type refers to static file in the application source code's "resources" folder.
When file type mapping is "json", the file content will be rendered as a Map or a List from a JSON string.</p>
<p>The "map" constant type is used for two purposes:</p>
<p><em>1. Map of key-values</em></p>
<p>The following example illustrates creation of a map of key-values. In the first entry, a map of 2 key-values
is set as the input argument "myMap" of a user function. In the second entry, the map's values are retrieved
from the key "some.key" in base configuration and the environment variable "ENV_VAR_ONE".</p>
<pre><code class="language-text">'map(k1=v1, k2=v2) -&gt; myMap'
'map(k1=${some.key}, k2=${ENV_VAR_ONE}) -&gt; myMap'
</code></pre>
<blockquote>
<p><em>Note</em>: The comma character is used as a separator for each key-value pair. If the value contains a comma,
  the system cannot parse the key-values correctly. In this case, please use the 2nd method below.</p>
</blockquote>
<p><em>2. Mapping values from application.yml</em></p>
<p>The following input data mapping sets the value of "my.key" from the application.yml base configuration file
to the input argument "myKey" of a user function.</p>
<pre><code class="language-text">'map(my.key) -&gt; myKey'
</code></pre>
<p>The "map(my.key)" would set a primitive value (text, integer, float, boolean), a JSON object of key-values or
an array of values.</p>
<p><em>Special content type for output data mapping</em></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Keyword for the right-hand-side argument</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">File</td>
<td style="text-align: left;"><code>file(file_path)</code></td>
</tr>
<tr>
<td style="text-align: left;">File</td>
<td style="text-align: left;"><code>file(append:file_path)</code></td>
</tr>
</tbody>
</table>
<p>For output data mapping, the "file" content type is used to save some data from the output of a user function
to a file in the local file system. If the left-hand-side (LHS) resolved value is null, the file in the RHS
will be deleted. This allows you to clean up temporary files before your flow finishes.</p>
<p>An optional prefix "append" may be used to tell the system to append file content instead of overwriting it.</p>
<p><em>Decision value</em></p>
<p>The "decision" keyword applies to "right hand side" of output data mapping statement in a decision task only
(See "Decision" in the task section).</p>
<p><em>Each flow has its own input and output</em></p>
<p>Each function has its input headers, input body and output result set.
Optionally, a function can return an EventEnvelope object to hold its result set in the "body", a "status" code
and one or more header key-values.</p>
<p>Since each function is stateless, a state machine (with namespace <code>model.</code>) is available as a temporary memory store
for transaction states that can be passed from one task to another.</p>
<p>All variables are addressable using the standard dot-bracket convention.</p>
<p>For example, "hello.world" will retrieve the value <code>100</code> from this data structure:</p>
<pre><code class="language-json">{
  &quot;hello&quot;:  {
    &quot;world&quot;: 100
  }
}
</code></pre>
<p>and "numbers[1]" will retrieve the value <code>200</code> below:</p>
<pre><code class="language-json">{ &quot;numbers&quot;:  [100, 200] }
</code></pre>
<p>The assignment is done using the assignment (<code>-&gt;</code>) syntax.</p>
<p>In the following example, the HTTP input query parameter 'amount' is passed as input body argument 'amount'
to the task 'simple.decision'. The result (function "return value") from the task will be mapped to the
special "decision" variable that the flow engine will evaluate. This assumes the result is a boolean or
numeric value.</p>
<p>The "decision" value is also saved to the state machine (<code>model</code>) for subsequent tasks to evaluate.</p>
<pre><code class="language-yaml">  - input:
      - 'input.query.amount -&gt; amount'
    process: 'simple.decision'
    output:
      - 'result -&gt; decision'
      - 'result -&gt; model.decision'
</code></pre>
<h3 id="environment-variables">Environment variables</h3>
<p>You can use the standard <code>${ENV_VAR:default}</code> syntax to resolve environment variables or parameters from
the application.properties.</p>
<h3 id="runtime-model-variables">Runtime model variables</h3>
<p>To use a runtime model variable value as a key or constant, you can use the <code>{model.variable_name}</code> syntax.</p>
<p>For example,</p>
<pre><code class="language-yaml">  - input:
      - 'text(wonderful day) -&gt; model.world'
      - 'text(world) -&gt; model.pointer'
      - 'model.{model.pointer} -&gt; value1'
      - 'text(new {model.pointer}) -&gt; value2' 
      - 'text(keep {this}/{one} unchanged) -&gt; value3'  
    process: 'demo.function'
</code></pre>
<p><code>model.{model.pointer}</code> is resolved as <code>model.world</code>, giving value1 = <code>wonderful day</code> and
value2 = <code>new world</code>. </p>
<p>The text inside a set of brackets that is not a model variable will be kept unchanged, 
thus value3 = <code>keep {this}/{one} unchanged</code></p>
<p>The use of string substitution is subject to event script syntax validation. Therefore,</p>
<ol>
<li>When this feature is used in the left-hand-side of an input data mapping, it can be used to substitute a constant 
   or a segment of a key in the <code>input.</code> and <code>model.</code> namespaces. The above example shows the use of the
   model namespace in <code>model.{model.pointer} -&gt; value1</code>.</li>
<li>Similarly, when used in the left-hand-side of an output data mapping, it can be used to substitute a constant
   or a segment of a key in the <code>input.</code>, <code>model.</code>, <code>header.</code> or <code>result.</code> namespaces.</li>
<li>When used in the right-hand-side of an input data mapping, namespace is optional because it may map as an argument
   to a task.</li>
<li>When used in the right-hand-side of an output data mapping, it can be used to substitute a <code>model.</code> namespace,
   <code>file(</code> output, flow <code>output.</code> namespace or an external state machine <code>ext:</code> namespace.</li>
</ol>
<p><em>Important</em>:</p>
<ol>
<li>For security reason, the key inside the brackets must be a model variable.</li>
<li>The resolved value from a model variable must be either text or number.
   Otherwise, it will be converted to a value of "null".</li>
<li>For simplicity, nested substitution is not allowed. 
   i.e. <code>model.{model.{model.n}}</code> or <code>model.{model.list[model.n]}</code> will be rejected.</li>
<li>If the bracketed text is not a model variable, the brackets and the enclosed text will be kept unchanged.</li>
</ol>
<h3 id="handling-arrays-in-a-dataset">Handling arrays in a dataset</h3>
<p>An array of data elements is expressed as a list.</p>
<pre><code class="language-json">{ &quot;numbers&quot;:  [100, 200] }
</code></pre>
<p>As discussed earlier, an array element can be retrieved using a number as index. For example, to take
the second element with value 200 above, you can use this data mapping like this:</p>
<pre><code class="language-yaml">'input.body.numbers[1] -&gt; second_number'
</code></pre>
<p>In the above example, it is an "input data mapping". It maps the second element of value 200 as the
input argument "second_number" to a composable function.</p>
<p>For-loop feature is supported in pipeline in an event flow. It would be convenient to use the
iterator value as an index to map an input argument. We can do something like this:</p>
<pre><code class="language-yaml">'input.body.numbers[model.n] -&gt; second_number'
</code></pre>
<p>where <code>model.n</code> is the iterator value in a for-loop.</p>
<p>Similarly, it is possible to do output data mapping. For example,</p>
<pre><code class="language-yaml">'result.computed -&gt; model.list[model.n]'
</code></pre>
<p>To address an array element, we can use a number or a "dynamic model variable" as an index.
The model variable must resolved to a number.</p>
<blockquote>
<p><em>Note</em>: There are some consideration when using a dynamic model variable as an index. The left-hand-side
          of a data mapping is a GET operation. The right-hand-side is a SET operation. If the model
          variable is non-numeric, the GET operation will return null and SET operation will throw
          exception. To avoid setting an arbitrary high index, the size of the index is limited by
          the parameter "max.model.array.size" in application.yml</p>
</blockquote>
<h3 id="append-an-element-to-an-array">Append an element to an array</h3>
<p>An empty array index in the right hand side tells the system to append an element to an array.
For example, the value resolved from the left hand side "result.item1" and "result.item2" will be appended
to the model.items array in the state machine.</p>
<pre><code class="language-yaml">- 'result.item1 -&gt; model.items[]'
- 'result.item2 -&gt; model.items[]'
</code></pre>
<p>If model.items does not exist, the first element will be set as array index "0". Therefore, the above output
data mapping statements are the same as:</p>
<pre><code class="language-yaml">- 'result.item1 -&gt; model.items[0]'
- 'result.item2 -&gt; model.items[1]'
</code></pre>
<h3 id="simple-type-matching-and-conversion">Simple type matching and conversion</h3>
<p>Event script's state machine supports simple type matching and conversion for the model namespace.</p>
<p>This "impedance matching" feature allows us to accommodate minor interface contract changes without
refactoring business logic of a user function.</p>
<p>This is supported in both the left-hand-side and right-hand-side of both input and output data mappings.</p>
<p>For the left-hand-side, the state machine's model value is matched or converted to the target data type before
setting the value of the right-hand-side. The state machine values are unchanged.</p>
<p>For the right-hand-side, the matched or converted value is applied to the state machine's model value.</p>
<p>The syntax is <code>model.somekey:type</code> where "type" is one of the following:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Match value as</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">text</td>
<td style="text-align: left;">text string</td>
<td style="text-align: left;">model.someKey:text</td>
</tr>
<tr>
<td style="text-align: left;">binary</td>
<td style="text-align: left;">byte array</td>
<td style="text-align: left;">model.someKey:binary</td>
</tr>
<tr>
<td style="text-align: left;">int</td>
<td style="text-align: left;">integer or -1 if not numeric</td>
<td style="text-align: left;">model.someKey:int</td>
</tr>
<tr>
<td style="text-align: left;">long</td>
<td style="text-align: left;">long or -1 if not numeric</td>
<td style="text-align: left;">model.someKey:long</td>
</tr>
<tr>
<td style="text-align: left;">float</td>
<td style="text-align: left;">float or -1 if not numeric</td>
<td style="text-align: left;">model.someKey:float</td>
</tr>
<tr>
<td style="text-align: left;">double</td>
<td style="text-align: left;">double or -1 if not numeric</td>
<td style="text-align: left;">model.someKey:double</td>
</tr>
<tr>
<td style="text-align: left;">boolean</td>
<td style="text-align: left;">true or false</td>
<td style="text-align: left;">model.someKey:boolean</td>
</tr>
<tr>
<td style="text-align: left;">boolean(value)</td>
<td style="text-align: left;">true if value matches</td>
<td style="text-align: left;">model.someKey:boolean(positive)</td>
</tr>
<tr>
<td style="text-align: left;">boolean(value=true)</td>
<td style="text-align: left;">true if value matches</td>
<td style="text-align: left;">model.someKey:boolean(positive=true)</td>
</tr>
<tr>
<td style="text-align: left;">boolean(value=false)</td>
<td style="text-align: left;">false if value matches</td>
<td style="text-align: left;">model.someKey:boolean(negative=false)</td>
</tr>
<tr>
<td style="text-align: left;">and(model.key)</td>
<td style="text-align: left;">boolean AND of 2 model keys</td>
<td style="text-align: left;">model.someKey:and(model.another)</td>
</tr>
<tr>
<td style="text-align: left;">or(model.key)</td>
<td style="text-align: left;">boolean OR of 2 model keys</td>
<td style="text-align: left;">model.someKey:or(model.another)</td>
</tr>
<tr>
<td style="text-align: left;">!model.key</td>
<td style="text-align: left;">negate of a model variable</td>
<td style="text-align: left;">!model.someKey</td>
</tr>
<tr>
<td style="text-align: left;">substring(start, end)</td>
<td style="text-align: left;">extract a substring</td>
<td style="text-align: left;">model.someKey:substring(0, 5)</td>
</tr>
<tr>
<td style="text-align: left;">substring(start)</td>
<td style="text-align: left;">extract a substring</td>
<td style="text-align: left;">model.someKey:substring(5)</td>
</tr>
<tr>
<td style="text-align: left;">concat(vars...)</td>
<td style="text-align: left;">concat model variables &amp; text</td>
<td style="text-align: left;">model.a:concat(model.b, text(!))</td>
</tr>
<tr>
<td style="text-align: left;">b64</td>
<td style="text-align: left;">byte-array to Base64 text</td>
<td style="text-align: left;">model.someKey:b64</td>
</tr>
<tr>
<td style="text-align: left;">b64</td>
<td style="text-align: left;">Base64 text to byte-array</td>
<td style="text-align: left;">model.someKey:b64</td>
</tr>
<tr>
<td style="text-align: left;">uuid</td>
<td style="text-align: left;">generated UUID-4 value</td>
<td style="text-align: left;">model.unique_id:uuid</td>
</tr>
<tr>
<td style="text-align: left;">length</td>
<td style="text-align: left;">length of model list variable</td>
<td style="text-align: left;">model.someList:length</td>
</tr>
</tbody>
</table>
<p>For Base64 type matching, it handles two symmetrical use cases. If the key-value is a text string,
the system would assume it is a Base64 text string and convert it to a byte-array. If the key-value
is a byte-array, the system will encode it into a Base64 text string.</p>
<p>For uuid type matching, the system will ignore the value of the model variable in the left hand
side because UUID is a generated value. When using it in the right hand side, the model variable
will be updated with a generated UUID value accordingly.</p>
<p>For simplicity of syntax, each type matching command is a single operation. For more complex
operation such as multiple AND, OR and NEGATE operators, you can configure multiple steps of
operation.</p>
<p>For string concatenation, you may concat a model variable with one or more model variables and
text constants. A more convenient alternative to string concatenation is the use of "runtime model
variables". You can replace the "concat" method with "runtime model variable" method as follows:</p>
<pre><code class="language-yaml"># assuming the bearer token value is in model.token
- 'text(Bearer ) -&gt; model.bearer'
- 'model.bearer:concat(model.token) -&gt; authorization'

# the above is the same as
- 'text(Bearer {model.token}) -&gt; authorization'
</code></pre>
<p>An interesting use case is a simple decision task using the built-in no-op function.
For boolean with value matching, you can test if the key-value in the left-hand-side is a null
value. For example, when a control file for the application is not available, your application will
switch to run in dev mode.</p>
<p>A sample task may look like this:</p>
<pre><code class="language-yaml">first.task: 'no.op'

tasks:
- input:
    - 'file(binary:/tmp/interesting-config-file) -&gt; model.is-local:boolean(null=true)'
  process: 'no.op'
  output:
    - 'model.is-local -&gt; decision'
  execution: decision
  next:
    - 'start.in.dev.mode'
    - 'start.in.cloud'
</code></pre>
<p>Another use case is type conversion for HTTP path parameter which is always a text string.
If your composable function requires a path parameter to be accepted as an integer, you can do this:</p>
<pre><code class="language-yaml">- input:
    - 'input.path_parameter.userid -&gt; model.userid:int'
    - 'model.userid -&gt; userid'
</code></pre>
<p>The above input data mapping example illustrates the use of a model variable to convert a text parameter
into an integer. Note that if the path parameter is not numeric, the converted value will be -1.</p>
<blockquote>
<p><em>Note</em>: The system only supports "type matching modifier" in the model namespace because of
          the design principle of data immutability. The model is a state machine for a flow instance.
          As a temporary store, we can use it for this purpose without side effect that the user application
          would accidentally modify a value of the flow's input.</p>
</blockquote>
<h3 id="convenient-data-mapping-using-model-variable">Convenient data mapping using model variable</h3>
<p>To address the common use case of using a model variable as an intermediate value, the system supports the following
formats for input data mapping and output data mapping.</p>
<pre><code class="language-text">// 2-part data mapping format
LHS -&gt; RHS
// 3-part data mapping format
LHS -&gt; model.variable -&gt; RHS
</code></pre>
<p>For the 2-part data mapping format, there are left-hand-side and right-hand-side where the value retrieved
from the left-hand-side variable is mapped to the right-hand-side.</p>
<p>The 3-part data mapping allows us to use a model variable as an intermediate for simple type matching.</p>
<p>In the previous example, it uses two entries to convert a HTTP path parameter from a text string to a number and
set the number as input argument. The configuration syntax can be simplified as follows:</p>
<pre><code class="language-yaml">- input:
    - 'input.path_parameter.userid -&gt; model.userid:int -&gt; userid'
</code></pre>
<p>The above 3-part data mapping entry will be expanded into two entries internally. This extra processing is done
at the "CompileFlows" step and thus there is no impact to the task execution speed.</p>
<p>Please note that the 3-part data mapping format is not supported when the left-hand-side is a text constant.
It is because a text constant may contain any special characters including the mapping signature <code>-&gt;</code>.</p>
<h3 id="metadata-for-each-flow-instance">Metadata for each flow instance</h3>
<p>For each flow instance, the state machine in the "model" namespace provides the following metadata that
you can use in the input/output data mapping. For example, you can set this for an exception handler to
log additional information.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Keyword</th>
<th style="text-align: left;">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Flow ID</td>
<td style="text-align: left;"><code>model.flow</code></td>
<td style="text-align: left;">The ID of the event flow config</td>
</tr>
<tr>
<td style="text-align: left;">Trace ID</td>
<td style="text-align: left;"><code>model.trace</code></td>
<td style="text-align: left;">Optional traceId when tracing is turned on</td>
</tr>
<tr>
<td style="text-align: left;">Correlation ID</td>
<td style="text-align: left;"><code>model.cid</code></td>
<td style="text-align: left;">Correlation ID of the inbound request</td>
</tr>
</tbody>
</table>
<h3 id="special-handling-for-header">Special handling for header</h3>
<p>When function input keyword <code>header</code> is specified in the "right hand side" of an input data mapping statement,
it refers to the input event envelope's headers. Therefore, it assumes the "left hand side" to resolve into
a JSON object of key-values. Otherwise, it will reject the input data mapping statement with an error like this:</p>
<pre><code class="language-text">Invalid input mapping 'text(ok) -&gt; header', expect: JSON, Actual: string
</code></pre>
<p>When function input namespace <code>header.</code> is used, the system will map the value resolved from the "left hand side"
statement into the specific header.</p>
<p>For example, the input data mapping statement <code>text(ok) -&gt; header.demo</code> will set "demo=ok" into the input event
envelope's headers.</p>
<p>When function output keyword <code>header</code> is specified in the "left hand side" of an output data mapping statement,
it will resolve as a JSON object of key-values from the function output event envelope's headers.</p>
<p>Similarly, when function output namespace <code>header.</code> is used, the system will resolve the value from a specific
key of the function output event envelope's headers.</p>
<h3 id="function-input-and-output">Function input and output</h3>
<p>To support flexible input data mapping, the input to a function must be either a JSON object of key-values.
However, the output (i.e. result set) of a function can be JSON object or primitive (boolean, string, number,
Buffer, etc.).</p>
<p>Your function must implement the <code>Composable</code> interface to configure input and output.</p>
<p>Since a data structure is passed to your function's input argument as key-values, you may create a class
to deserialize the data structure.</p>
<p>To tell the system that your function is expecting input as a JSON object, you can use the special notation <code>*</code> 
on the right hand side.</p>
<p>For example, the following entry tells the system to set the value in "model.dataset" as a JSON payload.</p>
<pre><code class="language-yaml">  - input:
      - 'model.dataset -&gt; *'
</code></pre>
<blockquote>
<p><em>Note</em>: If the value from the left hand side is not a JSON, the system will ignore the input mapping command and
  print out an error message in the application log.</p>
</blockquote>
<h3 id="setting-function-input-headers">Setting function input headers</h3>
<p>When function input body is used to hold a JSON object, we may use function input headers to pass other arguments
to the function without changing the data structure of a user defined JSON object of key-values.</p>
<p>In the following example, the HTTP query parameter "userid" will be mapped to the function input header
key "user" and the HTTP request body will be mapped to the function input body.</p>
<pre><code class="language-yaml">  - input:
      - 'input.query.userid -&gt; header.user'
      - 'input.body -&gt; *'
    process: 'my.user.function'
    output:
      - 'text(application/json) -&gt; output.header.content-type'
      - 'result -&gt; output.body'
</code></pre>
<h2 id="task-types">Task types</h2>
<h3 id="decision-task">Decision task</h3>
<p>A decision task makes decision to select the next task to execute. It has the tag <code>execution=decision</code>.</p>
<p>In the output data mapping section, it must map the corresponding result set or its key-value to the <code>decision</code> object.</p>
<p>The "next" tag contains a list of tasks to be selected based on the decision value.</p>
<p>If decision value is boolean, a <code>true</code> value will select the first task. Otherwise, the second task will be selected.</p>
<p>If decision value is an integer, the number should <em>start from 1</em> where the corresponding "next" task
will be selected.</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.query.decision -&gt; decision'
    process: 'simple.decision'
    output:
      - 'result -&gt; model.decision'
      - 'result -&gt; decision'
    description: 'Simple decision test'
    execution: decision
    next:
      - 'decision.case.one'
      - 'decision.case.two'
</code></pre>
<h3 id="response-task">Response task</h3>
<p>A response task will provide result set as a flow output or "response". A response task allows the flow to respond
to the user or caller immediately and then move on to the next task asynchronously. For example, telling the user
that it has accepted a request and then moving on to process the request that may take longer time to run.</p>
<p>A response task has the tag <code>execution=response</code> and a "next" task.</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.path_parameter.user -&gt; user'
      - 'input.query.seq -&gt; sequence'
    process: 'sequential.one'
    output:
      - 'result -&gt; model.json'
      - 'result -&gt; output.body'
    description: 'Pass a JSON to another task'
    execution: response
    next:
      - 'sequential.two'
</code></pre>
<h3 id="end-task">End task</h3>
<p>An end task indicates that it is the last task of the transaction processing in a flow. If the flow has not executed
a response task, the end task will generate the response. Response is defined by output data mapping.</p>
<p>This task has the tag <code>execution=end</code>.</p>
<p>For example, the greeting task in the unit tests is an end task.</p>
<pre><code class="language-yaml">    - input:
        - 'input.path_parameter.user -&gt; user'
      process: 'greeting.demo'
      output:
        - 'text(application/json) -&gt; output.header.content-type'
        - 'result -&gt; output.body'
      description: 'Hello World'
      execution: end
</code></pre>
<h3 id="sequential-task">Sequential task</h3>
<p>Upon completion of a sequential task, the next task will be executed.</p>
<p>This task has the tag <code>execution=sequential</code>.</p>
<p>In the following example, <code>sequential.two</code> will be executed after <code>sequential.one</code>.</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.path_parameter.user -&gt; user'
      - 'input.query.seq -&gt; sequence'
    process: 'sequential.one'
    output:
      - 'result -&gt; model.json'
    description: 'Pass a JSON to another task'
    execution: sequential
    next:
      - 'sequential.two'
</code></pre>
<h3 id="parallel-task">Parallel task</h3>
<p>Upon completion of a <code>parallel</code> task, all tasks in the "next" task list will be executed in parallel.</p>
<p>This task has the tag <code>execution=parallel</code>.</p>
<p>In this example, <code>parallel.one</code> and <code>parallel.two</code> will run after <code>begin.parallel.test</code></p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'int(2) -&gt; count'
    process: 'begin.parallel.test'
    output: []
    description: 'Setup counter for two parallel tasks'
    execution: parallel
    next:
      - 'parallel.one'
      - 'parallel.two'
</code></pre>
<h3 id="fork-n-join-task">Fork-n-join task</h3>
<p>Fork-n-join is a parallel processing pattern.</p>
<p>A "fork" task will execute multiple "next" tasks in parallel and then wait for the result sets before running
the "join" task.</p>
<p>This task has the tag <code>execution=fork</code>. It must have a list of "next" tasks and a "join" task.</p>
<p>It may look like this:</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.path_parameter.user -&gt; user'
      - 'input.query.seq -&gt; sequence'
    process: 'sequential.one'
    output:
      - 'result -&gt; model.json'
    description: 'Pass a JSON to another task'
    execution: fork
    next:
      - 'echo.one'
      - 'echo.two'
    join: 'join.task'
</code></pre>
<h3 id="dynamic-fork-n-join-task">Dynamic fork-n-join task</h3>
<p>A special version of the fork-n-join pattern is called <code>dynamic fork-n-join</code> which refers to parallel processing
of multiple instances of the same "next" task for each element in a list.</p>
<p>For example, you have a list of 100 elements in an incoming request and each element would be processed by the
same backend service. You want to process the 100 elements in parallel by multiple instances of a service wraper
that connects to the backend service.</p>
<p>The use case can be configured like this:</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.elements -&gt; elements'
    process: 'data.validation'
    output:
      - 'result.elements -&gt; model.elements'
    description: 'Validate list of elements'
    execution: fork
    source: 'model.elements'    
    next:
      - 'element.processor'
    join: 'join.task'

  - name: 'element.processor'
    input:
      - 'model.elements.ITEM -&gt; item'
      - 'model.elements.INDEX -&gt; index'
    process: 'v1.element.processor'
    output: []
    description: 'Hello world'
    execution: sink    
</code></pre>
<p>To handle this special use case, you can add a <code>source</code> parameter in the fork task. The "source" parameter
tells the system which model variable holds the list of elements. You should only configure a single "next"
task. The system will spin up parallel instances of the <code>next</code> task to handle each element from the model
variable containing the list.</p>
<p>In the input data mapping section, there are two special suffixes <code>.ITEM</code> and <code>.INDEX</code>. The system will iterate
the list of elements and spin up an instance of the "next" task to retrieve the element (item) and index of
the element in the list. The two special suffixes are relevant only when adding to the model variable configured
in the "source" parameter.</p>
<p><em>Important</em>:</p>
<ol>
<li>The model variables with special suffixes '.ITEM' and '.INDEX' are virtual objects for the purpose
   of mapping as input arguments to a task. They cannot be used as regular model variables.</li>
<li>Dynamic fork-n-join is designed to execute the same task for a list of elements in parallel.
   It does not support subflow. i.e. the "process" tag of the "next" task cannot be a subflow.</li>
</ol>
<h3 id="sink-task">Sink task</h3>
<p>A sink task is a task without any next tasks. Sink tasks are used by fork-n-join and pipeline tasks as reusable modules.</p>
<p>This task has the tag <code>execution=sink</code>.</p>
<pre><code class="language-yaml">  - input:
      - 'text(hello-world-two) -&gt; key2'
    process: 'echo.two'
    output:
      - 'result.key2 -&gt; model.key2'
    description: 'Hello world'
    execution: sink
</code></pre>
<h2 id="pipeline-feature">Pipeline feature</h2>
<p>Pipeline is an advanced feature of Event Script.</p>
<h3 id="pipeline-task">Pipeline task</h3>
<p>A pipeline is a list of tasks that will be executed orderly within the current task.</p>
<p>When the pipeline is done, the system will execute the "next" task.</p>
<p>This task has the tag <code>execution=pipeline</code>.</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.path_parameter.user -&gt; user'
      - 'input.query.seq -&gt; sequence'
    process: 'sequential.one'
    output:
      - 'result -&gt; model.json'
    description: 'Pass a JSON to another task'
    execution: pipeline
    pipeline:
      - 'echo.one'
      - 'echo.two'
    next:
      - 'echo.three'
</code></pre>
<p>Some special uses of pipelines include "for/while-loop" and "continue/break" features.</p>
<h3 id="simple-for-loop">Simple for-loop</h3>
<p>In the following example, the <code>loop.statement</code> contains a for-loop that uses a variable in the state machine to
evaluate the loop.</p>
<p>In this example, the pipeline will be executed three times before passing control to the "next" task.</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.path_parameter.user -&gt; user'
      - 'input.query.seq -&gt; sequence'
    process: 'sequential.one'
    output:
      - 'result -&gt; model.json'
    description: 'Pass a JSON to another task'
    execution: pipeline
    loop:
      statement: 'for (model.n = 0; model.n &lt; 3; model.n++)'
    pipeline:
      - 'echo.one'
      - 'echo.two'
      - 'echo.three'
    next:
      - 'echo.four'
</code></pre>
<h3 id="simple-while-loop">Simple while loop</h3>
<p>The <code>loop.statement</code> may use a "while loop" syntax like this:</p>
<pre><code class="language-yaml">    loop:
      statement: 'while (model.running)'
</code></pre>
<p>To exit the above while loop, one of the functions in the pipeline should return a boolean "false" value with
output "data mapping" to the <code>model.running</code> variable.</p>
<h3 id="for-loop-with-breakcontinue-decision">For loop with break/continue decision</h3>
<p>In the following example, the system will evaluate if the <code>model.quit</code> variable is true.
If yes, the <code>break</code> or <code>continue</code> condition will be executed.</p>
<p>The state variable is obtained after output data mapping and any task in the pipeline can set a key-value for
mapping into the state variable.</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.path_parameter.user -&gt; user'
      - 'input.query.seq -&gt; sequence'
    process: 'sequential.one'
    output:
      - 'result -&gt; model.json'
    description: 'Pass a JSON to another task'
    execution: pipeline
    loop:
      statement: 'for (model.n = 0; model.n &lt; 3; model.n++)'
      condition: 'if (model.quit) break'
    pipeline:
      - 'echo.one'
      - 'echo.two'
      - 'echo.three'
    next:
      - 'echo.four'
</code></pre>
<p>Note that the "condition" parameter can be a single condition or a list of conditions.
In the following example, the system will evaluate both the model.quit and model.jump values.</p>
<pre><code class="language-yaml">    loop:
      statement: 'for (model.n = 0; model.n &lt; 3; model.n++)'
      condition: 
        - 'if (model.quit) break'
        - 'if (model.jump) break'
</code></pre>
<h2 id="handling-exception">Handling exception</h2>
<p>You can define exception handler at the top level or at the task level.</p>
<p>Exception is said to occur when a user function throws exception or returns an EventEnvelope object with
a status code equals to or larger than 400.</p>
<p>The event status uses the same numbering scheme as HTTP exception status code.
Therefore, status code less than 400 is not considered an exception.</p>
<h3 id="top-level-exception-handler">Top-level exception handler</h3>
<p>Top-level exception handler is a "catch-all" handler. You can define it like this:</p>
<pre><code class="language-yaml">flow:
  id: 'greetings'
  description: 'Simplest flow of one task'
  ttl: 10s
  exception: 'v1.my.exception.handler'
</code></pre>
<p>In this example, the <code>v1.my.exception.handler</code> should point to a corresponding exception handler that you provide.</p>
<p>The following input arguments will be delivered to your function when exception happens.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Key</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">status</td>
<td style="text-align: left;">Exception status code</td>
</tr>
<tr>
<td style="text-align: left;">message</td>
<td style="text-align: left;">Error message</td>
</tr>
<tr>
<td style="text-align: left;">stack</td>
<td style="text-align: left;">Stack trace in a text string</td>
</tr>
</tbody>
</table>
<p>The exception handler function can be an "end" task to abort the transaction or a decision task
to take care of the exception. For example, the exception handler can be a "circuit-breaker" to retry a request.</p>
<blockquote>
<p><em>Note</em>: for efficiency, stack trace transport is limited to the first 10 lines.</p>
</blockquote>
<h3 id="task-level-exception-handler">Task-level exception handler</h3>
<p>You can attach an exception handler to a task. One typical use is the "circuit breaker" pattern.
In the following example, the user function "breakable.function" may throw an exception for some error condition.
The exception will be caught by the "v1.circuit.breaker" function.</p>
<pre><code class="language-yaml">  - input:
      - 'input.path_parameter.accept -&gt; accept'
      - 'model.attempt -&gt; attempt'
    process: 'breakable.function'
    output:
      - 'int(0) -&gt; model.attempt'
      - 'text(application/json) -&gt; output.header.content-type'
      - 'result -&gt; output.body'
    description: 'This demo function will break until the &quot;accept&quot; number is reached'
    execution: end
    exception: 'v1.circuit.breaker'
</code></pre>
<p>The configuration for the circuit breaker function may look like this:</p>
<pre><code class="language-yaml">  - input:
      - 'model.attempt -&gt; attempt'
      - 'int(2) -&gt; max_attempts'
      - 'error.code -&gt; status'
      - 'error.message -&gt; message'
      - 'error.stack -&gt; stack'
    process: 'v1.circuit.breaker'
    output:
      - 'result.attempt -&gt; model.attempt'
      - 'result.decision -&gt; decision'
      - 'result.status -&gt; model.status'
      - 'result.message -&gt; model.message'
    description: 'Just a demo circuit breaker'
    execution: decision
    next:
      - 'breakable.function'
      - 'abort.request'
</code></pre>
<p>An exception handler will be provided with the "error" object that contains error code, error message and a
stack trace. The exception handler can inspect the error object to make decision of the next step.</p>
<p>For circuit breaker, we can keep the number of retry attempts in the state machine under "model.attempt" or any
key name that you prefer. In the above example, it sets an integer constant of 2 for the maximum attempts.</p>
<p>The circuit breaker can then evaluate if the number of attempts is less than the maximum attempts. If yes, it will
return a decision of "true" value to tell the system to route to the "breakable.function" again. Otherwise, it will
return a decision of "false" value to abort the request.</p>
<p>A more sophisticated circuit breaker may be configured with "alternative execution paths" depending on the error
status and stack trace. In this case, the decision value can be a number from 1 to n that corresponds to the "next"
task list.</p>
<p>Exception handlers may be used in both queries and transactions. For a complex transaction, the exception handler
may implement database rollback logic or recovery mechanism.</p>
<h3 id="best-practice">Best practice</h3>
<p>When a task-level exception handler throws exception, it will be caught by the top-level exception handler, if any.</p>
<p>A top-level exception handler should not throw exception. Otherwise it may go into an exception loop.</p>
<p>Therefore, we recommend that an exception handler should return regular result set in a JSON object.</p>
<p>An example of task-level exception handler is shown in the "hello-exception.ts" class in the "task" folder
where it set the status code in the result set so that the system can map the status code from the result set
to the next task or to the HTTP output status code.</p>
<h2 id="advanced-features">Advanced features</h2>
<h3 id="no-operation-function">No-operation function</h3>
<p>A convenient no-operation function with the route name <code>no.op</code> is available. It can be used when you want
to perform some input/output data mapping without executing any business logic.</p>
<h3 id="generic-resilience-handler-function">Generic resilience handler function</h3>
<p>Another useful built-in function is a resilience handler with the route name <code>resilience.handler</code>.</p>
<p>It is a generic resilience handler. It will retry, abort, use an alternative path or exercise a brief backoff.</p>
<p><img alt="Resilience Handler" src="../diagrams/resilience-handler.png" /></p>
<blockquote>
<p>Figure 2 - Resilience Handler</p>
</blockquote>
<p>The following parameters (input data mapping) define behavior for the handler:</p>
<ol>
<li><code>max_attempts</code> - when the handler has used all the attempts, it will abort.</li>
<li><code>attempt</code> - this tells the handler how many attempts it has tried</li>
<li><code>status</code> - you should map the error status code in this field</li>
<li><code>message</code> - you should map the error message in this field</li>
<li><code>alternative</code> - the optional codes and range of status codes to tell the handler to reroute</li>
<li><code>delay</code> - the delay in milliseconds before exercising retry or reroute. Minimum value is 10 ms.
              Delay is skipped for the first retry. This slight delay is a protection mechanism.</li>
</ol>
<p>Optional backoff behavior:</p>
<ol>
<li><code>cumulative</code> - the total number of failures since last success or backoff reset if any</li>
<li><code>backoff</code> - the time of a backoff period (epoch milliseconds) if any</li>
<li><code>backoff_trigger</code> - the total number of failures that triggers a backoff</li>
<li><code>backoff_seconds</code> - the time to backoff after an abort has occurred.
    During this period, It will abort without updating attempt.
    This avoids overwhelming the target service that may result in recovery storm.</li>
</ol>
<p>Return value (output data mapping):</p>
<ol>
<li><code>result.attempt</code> - the handler will clear or increment this counter</li>
<li><code>result.cumulative</code> - the handler will clear or increment this counter. 
                          Not set if "backoff_trigger" is not given in input.</li>
<li><code>result.decision</code> - 1, 2 or 3 where 1=retry, 2=abort, 3=reroute that corresponds to the next tasks</li>
<li><code>result.status</code> - the status code that the handler aborts the retry or reroute. Not set if retry or reroute.</li>
<li><code>result.message</code> - the reason that the handler aborts the retry or reroute. Not set if retry or reroute.</li>
<li><code>result.backoff</code> - the time of a backoff period (epoch milliseconds). Not set if not in backoff mode.</li>
</ol>
<blockquote>
<p><em>Note</em>: "result.attempt" should be saved in the state machine with the "model." namespace.
           "result.cumulative" and "result.backoff" should be saved in the temporary file system
           or an external state machine.</p>
</blockquote>
<p>For more details, please refer to the event script <code>resilience-demo.yml</code> in the test resources folder 
and the unit test <code>will handle backoff, retry and abort in resilience handler</code> 
under the flow.test.ts class.</p>
<p>Extract of the task configuration for the resilience handler is shown as follows. 
In the following example, "my.task" is the function that is configured with the 'resilience.handler' as an exception
handler. The input data mapping tells the handler to enter into "backoff" period when the cumulative failure count
reaches the "backoff_trigger" threshold of 3. After that, all requests will be aborted until the backoff period expires.</p>
<pre><code class="language-yaml">  - input:
      - 'error.code -&gt; status'
      - 'error.message -&gt; message'
      - 'model.attempt -&gt; attempt'
      - 'int(10) -&gt; max_attempts'
      - 'text(401, 403-404) -&gt; alternative'
      - 'file(text:/tmp/resilience/cumulative) -&gt; cumulative'
      - 'file(text:/tmp/resilience/backoff) -&gt; backoff'
      - 'int(3) -&gt; backoff_trigger'
      - 'int(2) -&gt; backoff_seconds'
      - 'int(500) -&gt; delay'
    process: 'resilience.handler'
    output:
      - 'result.status -&gt; model.status'
      - 'result.message -&gt; model.message'
      - 'result.attempt -&gt; model.attempt'
      - 'result.decision -&gt; decision'
      - 'result.backoff -&gt; file(/tmp/resilience/backoff)'
      - 'result.cumulative -&gt; file(/tmp/resilience/cumulative)'
    description: 'Resilience handler with alternative path and backoff features'
    execution: decision
    next:
      - 'my.task'
      - 'abort.request'
      - 'alternative.task'
</code></pre>
<blockquote>
<p><em>Note</em>: When the "backoff" feature is enabled, you should configure the resilience handler as a gatekeeper
          to protect your user function. This allows the system to abort requests during the backoff period.</p>
</blockquote>
<p>You may also use this resilience handler as a starting point to write your own exception handler for more
complex recovery use cases.</p>
<h3 id="external-state-machine">External state machine</h3>
<p>The in-memory state machine is created for each query or transaction flow and it is temporal.</p>
<p>For complex transactions or long running work flows, you would typically want to externalize some transaction
states to a persistent store such as a distributed cache system or a high performance key-value data store.</p>
<p>In these use cases, you can implement an external state machine function and configure it in a flow.</p>
<p>Below is an example from a unit test. When you externalize a key-value to an external state machine,
you must configure the route name (aka level-3 functional topic) of the external state machine.</p>
<blockquote>
<p><em>Note</em>: Passing a <code>null</code> value to a key of an external state machine means "removal".</p>
</blockquote>
<pre><code class="language-yaml">external.state.machine: 'v1.ext.state.machine'

tasks:
  - input:
      # A function can call an external state machine using input or output mapping.
      # In this example, it calls external state machine from input data mapping.
      - 'input.path_parameter.user -&gt; ext:/${app.id}/user'
      - 'input.body -&gt; model.body'
      # demonstrate saving constant to state machine and remove it using model.none
      - 'text(world) -&gt; ext:hello'
      - 'model.none -&gt; ext:hello'
    process: 'no.op'
    output:
      - 'text(application/json) -&gt; output.header.content-type'
      # It calls external state machine again from output data mapping
      - 'input.body -&gt; ext:/${app.id}/body'
      - 'input.body -&gt; output.body'
      - 'text(message) -&gt; ext:test'
      - 'model.none -&gt; ext:test'
    description: 'Hello World'
    execution: end
</code></pre>
<p>The "external.state.machine" parameter is optional.</p>
<p>When present, the system will send a key-value from the current flow instance's state machine
to the function implementing the external state machine. The system uses the "ext:" namespace
to externalize a state machine's key-value.</p>
<blockquote>
<p><em>Note</em>: The delivery of key-values to the external state machine is asynchronous.
  Therefore, please assume eventual consistency.</p>
</blockquote>
<p>You should implement a user function as the external state machine.</p>
<p>The input interface contract to the external state machine for saving a key-value is:</p>
<pre><code class="language-shell">header.type = 'put'
header.key = key
body.data = value
</code></pre>
<p>Your function should save the input key-value to a persistent store.</p>
<p>In another flow that requires the key-value, you can add an initial task to retrieve from the persistent store
and do "output data mapping" to save to the in-memory state machine so that your transaction flow can use the
persisted key-values to continue processing.</p>
<p>In the unit tests of the event-script-engine subproject, these two flows work together:</p>
<pre><code class="language-shell">externalize-put-key-value
externalize-get-key-value
</code></pre>
<blockquote>
<p><em>IMPORTANT</em>: Events to an external state machine are delivered asynchronously. If you want to guarantee
  message sequencing, please do not set the "instances" parameter in the <code>preLoad</code> annotation.</p>
</blockquote>
<p>To illustrate a minimalist implementation, below is an example of an external state machine in the
event-script-engine's unit test section.</p>
<pre><code class="language-shell">class ExtStateMachine implements Composable {
  initialize(): Composable {
    return this;
  }
  async handleEvent(evt: EventEnvelope) {
    if (!evt.getHeader(KEY)) {
      throw new Error(&quot;Missing key in headers&quot;);
    }
    const type = evt.getHeader(TYPE);
    const key = evt.getHeader(KEY);
    const input = evt.getBody();
    if (PUT == type &amp;&amp; input instanceof Object &amp;&amp; 'data' in input) {
      var data = input['data'];
      if (data) {
          log.info(`Saving ${key} to store`);
          store[key] = data;
          return true;
      }
    }
    if (GET == type) {
        const v = store[key];
        if (v) {
            log.info(`Retrieve ${key} from store`);
            return v;
        } else {
            return null;
        }
    }
    if (REMOVE == type) {
        if (key in store) {
            delete store[key];
            log.info(`Removed ${key} from store`);
            return true;
        } else {
            return false;
        }
    }
    return false;
  }  
}
</code></pre>
<p>For more sophisticated operation, you may also configure the external state machine as a "flow" like this:</p>
<pre><code class="language-yaml">external.state.machine: 'flow://ext-state-machine'
</code></pre>
<p>You can then define the flow for "ext-state-machine" like this:</p>
<pre><code class="language-yaml">flow:
  id: 'ext-state-machine'
  description: 'Flow to execute an external state machine'
  ttl: 10s

first.task: 'v1.ext.state.machine'

tasks:
  - input:
      - 'input.header.key -&gt; header.key'
      - 'input.header.type -&gt; header.type'
      - 'input.body.data -&gt; data'
    process: 'v1.ext.state.machine'
    output: []
    description: 'Execute external state machine'
    execution: end
</code></pre>
<blockquote>
<p><em>Note</em>: By definition, external state machine flow is outside the scope of the calling flow.</p>
</blockquote>
<h3 id="future-task-scheduling">Future task scheduling</h3>
<p>You may add a delay tag in a task so that it will be executed later.
This feature is usually used for unit tests or "future task scheduling".</p>
<p>Since the system is event-driven and non-blocking, the delay is simulated by event scheduling.
It does not block the processing flow.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Fixed delay</td>
<td style="text-align: left;">Milliseconds</td>
<td style="text-align: left;">delay: '1000 ms'</td>
</tr>
<tr>
<td style="text-align: left;">Variable delay</td>
<td style="text-align: left;">State machine variable</td>
<td style="text-align: left;">delay: model.delay</td>
</tr>
</tbody>
</table>
<p>Note that the "ms" suffix is optional for documentation purpose. It denotes milliseconds if present.</p>
<p>When delay is set to a state variable that its value is not configured by a prior data mapping,
the delay command will be ignored.</p>
<p>An example task that has an artificial delay of 2 seconds:</p>
<pre><code class="language-yaml">tasks:
  - input:
      - 'input.path_parameter.user -&gt; user'
      - 'input.query.ex -&gt; exception'
      - 'text(hello world) -&gt; greeting'
    process: 'greeting.test'
    output:
      - 'text(application/json) -&gt; output.header.content-type'
      - 'result -&gt; output.body'
    description: 'Hello World'
    execution: end
    delay: '2000 ms'
</code></pre>
<h3 id="using-worker-threads">Using Worker Threads</h3>
<p>In some use cases, there is a need to use legacy libraries and open sources that we cannot refactor
into composable functions.</p>
<p>We have provided a worked example to encapsulate any legacy library running in a worker thread to
behave as a composable function. This allows you to accelerate integration with existing enterprise
software assets for production use so that you can gradually and orderly refactor them into composable
functions.</p>
<p>Please review the composable-worker.ts source file to examine how it encapsulates a worker thread:
<a href="https://github.com/Accenture/mercury-composable-examples">Composable example repository</a></p>
<p>The composable-worker.ts class may be used as a template:
<a href="https://github.com/Accenture/mercury-composable-examples/blob/main/node/composable-example/src/workers/composable-worker.ts">ComposableWorker</a></p>
<p>An extract of the source code is shown below.</p>
<pre><code class="language-javascript">export class ComposableWorker implements Composable {

    @preload('composable.worker.demo', 5, true, true)
    initialize(): Composable {
        return this;
    }

    async handleEvent(evt: EventEnvelope) {
        // deferred startup until triggered by autostart or your own setup task
        if (!loaded &amp;&amp; 'start' == evt.getHeader('type')) {
            workerBridge();
        }
        if (worker) {
            // sending the original event to the worker to preserve metadata for tracing and correlation
            sendEventToWorker(evt);
        }
        return null;
    }
}
</code></pre>
<p>The <code>workerBridge</code> will start a new worker thread and the sendEventToWorker method will forward
an incoming event to the worker thread.</p>
<p>After processing the request, the worker thread would send acknowledgement or response back to the
main thread in the composable function that will forward it to the caller accordingly.</p>
<p>In the ComposableWorker sample code, it also illustrates the technique to pass environment variables,
application runtime arguments and the Composable configuration system from the main thread in your
Composable application to the legacy code in the worker thread.</p>
<p>A demo endpoint "GET /api/worker/demo" or "POST /api/worker/demo" is available to demonstrate the
ComposableWorker example. Using using the POST method, please set content-type to 'application/json'
and provide HTTP request payload as a JSON string.</p>
<p>Please use the worked example as a template to write your own composable function to encapsulate
some legacy code or open sources that you have no direct control.</p>
<p><br/></p>
<table>
<thead>
<tr>
<th style="text-align: center;">Chapter-3</th>
<th style="text-align: center;">Home</th>
<th style="text-align: center;">Chapter-5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a href="../CHAPTER-3/">REST Automation</a></td>
<td style="text-align: center;"><a href="../TABLE-OF-CONTENTS/">Table of Contents</a></td>
<td style="text-align: center;"><a href="../CHAPTER-5/">Build, Test and Deploy</a></td>
</tr>
</tbody>
</table>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../CHAPTER-3/" class="btn btn-neutral float-left" title="Chapter-3"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../CHAPTER-5/" class="btn btn-neutral float-right" title="Chapter-5">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../CHAPTER-3/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../CHAPTER-5/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
